---
title: Tutorial
description: Let's build your first application with Clojure Stack Lite
icon: Play
---

Now that we've created a new project, we're ready to get started. Let's build a simple application together.

## After Generating Your Project

The first recommended step is to check the code formatting, linting, tests, and outdated dependencies:

```shell
bb check
```

Next, let's initialize a git repository and commit the initial setup:

```shell
git init
git add .
git commit -am 'Initial commit'
```

## Starting the Server

Navigate to your project root directory and start the REPL:

```shell
cd myproject
bb clj-repl
```

Once in the REPL, run the application system which includes the server, database, and TailwindCSS CLI components:

```shell
user=> (reset)
```

_TODO: add link to editor setup documentation_

## Modifying the Starter Page

Let's make a simple change to the starter page to see how updates work. Open the `src/myproject/views.clj` file
and replace the `:h1` UI component with `[:h1 {:class ["text-5xl"]} "Hello world!"]`.
After reloading the page in your browser, you'll see that the title has been updated.

![Clojure Stack Lite starter page](@/public/starter_hello.png)

## Application System Components

The entry point of the application is `src/myproject/core.clj`. It contains a `main` function that runs the system with the production profile.
We use Integrant as a framework for managing all components of the system. The core components are `db` and `server`, which are defined in
`src/myproject/db.clj` and `src/myproject/server.clj` respectively. The default configuration of the server component is provided by the
`reitit-extras` library as a convenience. It offers several options to extend the server configuration.
If you need to customize or replace anything in the server configuration, you can copy the server definition from `reitit-extras` to your project.

In development mode, the entry point is `dev/user.clj`. Here we start the same system with the dev profile and an extension from `resources/config.dev` that contains
an additional component to run the `tailwindcss` CLI tool in watch mode. This automatically reloads CSS styles when files change. Since it's started as part of the application system, we don't need to
run it separately.

## Building Our Application

Now that everything is set up, we're ready to create our application. We'll build a movie list application called "Movies Lite".
This application will allow users to add new movies, view the list of movies, and delete entries from the list.

## Database Structure

For simplicity, we'll create a single table called `movie` with the fields `id`, `title`, `year`, and `director`.
To create this schema, add the following database migration by creating a new file `resources/migrations/0002.up.sql` with this content:

```sql title="resources/migrations/0002.up.sql"
CREATE TABLE movie (
    id INTEGER UNIQUE PRIMARY KEY AUTOINCREMENT NOT NULL,
    title TEXT NOT NULL,
    year INTEGER NOT NULL,
    director TEXT NOT NULL
);
```

Migrations are applied automatically when the system starts. To apply our new migration, run `(reset)` in the REPL.
Afterward, you can connect to the database using any SQLite client (such as [TablePlus](https://tableplus.com/)) to verify that the `movie` table was created successfully:

![Movies DB table](@/public/lite_movies_db_table.png)

## Application UI Layout

To visualize all parts of the application, let's create a UI layout for our main page.
Let's examine `src/myproject/views.clj`. This namespace contains functions that convert data to Hiccup templates,
which will be transformed into HTML during the response rendering process. The namespace includes a `base` function that provides the default setup for all pages,
including the page title, static files, and a placeholder for any content we want to display.

Here's a mockup of the page we're going to build:

![UI mockup](@/public/lite_mockup.png)

The page features a title and a table listing movies. Each row has a "Delete" button in the last column.
At the bottom of the table, there's a form for adding new movies.

Our `home-page` function and additional functions will look like:

```clojure title="src/myproject/views.clj"
; ...
(defn list-item
  [{:keys [movie]}]
  [:tr
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:title movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:year movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:director movie)]
   [:td {:class ["px-6" "py-4"]}
    [:button
     {:class ["text-red-400" "hover:bg-gray-50" "bg-white" "border"
              "border-gray-300" "rounded-md" "px-3" "py-1" "cursor-pointer"]}
     "Delete"]]])

(defn form-input
  [{:keys [field-name field-type attrs]}]
  [:div
   {:class ["flex" "flex-col"]}
   [:input (merge {:class ["w-full" "border" "border-gray-300" "rounded-md" "px-3" "py-2"]
                   :type field-type
                   :name field-name
                   :placeholder (str "Enter " field-name)}
                  attrs)]])

(defn form
  []
  [:form
   (cond-> {:id "form-create-movie"
            :class ["border-t" "border-gray-200" "bg-gray-50" "p-6"]})
   [:div {:class ["grid" "grid-cols-1" "md:grid-cols-4" "gap-4"]}
    (form-input {:field-name "title"
                 :field-type "text"})
    (form-input {:field-name "year"
                 :field-type "number"
                 :attrs {:min 1888}})
    (form-input {:field-name "director"
                 :field-type "text"})
    [:div {:class ["flex" "flex-col"]}
     [:button {:class ["bg-blue-600" "text-white" "rounded-md" "px-4" "py-2"
                       "hover:bg-blue-700" "cursor-pointer"]}
      "Create"]]]])

(defn home-page
  [{:keys [movies]}]
  (base
    [:div {:id "content"
           :class ["container" "mx-auto" "p-6" "max-w-4xl"]}
     [:div {:class ["mb-10" "flex" "justify-between" "items-center"]}
      [:h1 {:class ["text-2xl" "font-semibold" "text-gray-800"]} "Movies Lite"]]
     [:div {:class ["bg-white" "rounded-lg" "shadow-md" "overflow-hidden" "border"
                    "border-gray-200"]}
      [:div {:class ["overflow-x-auto"]}
       [:table {:class ["min-w-full" "divide-y" "divide-gray-200"]}
        [:thead {:class ["bg-white"]}
         [:tr
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Title"]
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Year"]
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Director"]
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Actions"]]]
        [:tbody {:id "table-content"
                 :class ["bg-white" "divide-y" "divide-gray-200"]}
         (for [movie movies]
           (list-item {:movie movie}))]]]
      (form)]]))
```

We've separated the list item, form, and form inputs into individual components for better organization and reusability. This approach will be particularly helpful when we need to render these components separately for newly created movies in the next section.

Now, let's update our `home-handler` to pass some sample data for `movies` to display on the page:

```clojure title="src/myproject/handlers.clj"
; ...
(defn home-handler
  [_]
  (-> {:movies [{:title "Movie 1"
                 :year 2023
                 :director "Director 1"}
                {:title "Movie 2"
                 :year 2022
                 :director "Director 2"}]}
      (views/home-page)
      (reitit-extras/render-html)))
```

After refreshing page in the browser it will look like:

![Page layout](@/public/lite_page_layout.png)

## Creating Movies

Now that we have the basic UI components for the table and form, let's implement the functionality to create new movies by adding a route and handler.

### Backend Implementation

First, let's add SQL queries for creating and retrieving movies. Create a new file `queries.clj`:

```clj title="src/myproject/queries.clj"
(ns myproject.queries
  (:require [myproject.db :as db]))

(defn get-movie-list
  [db]
  (db/exec! db {:select [:*]
                :from [:movie]
                :order-by [:id]}))

(defn create-movie
  [db {:keys [title year director]}]
  (db/exec-one! db {:insert-into :movie
                    :values [{:title title
                              :year year
                              :director director}]
                    :returning [:*]}))
```

Now we can add a new handler for creating a movie:

```clojure title="src/myproject/handlers.clj"
(ns myproject.handlers
  // [!code highlight]
  (:require [myproject.queries :as queries]
            ; ...
            )

; ...

(defn create-movie-handler
  "Render a new table item with newly created movie."
  [{router :reitit.core/router
    :keys [context params]}]
  (-> (list
        (views/form {:router router})
        [:template
         [:tbody
          {:hx-swap-oob "beforeend:#table-content"}
          (views/list-item {:router router
                            :movie (queries/create-movie (:db context) params)})]])
      (reitit-extras/render-html)
      (response/header "Content-Type" "text/html")))
```

The single parameter of a handler is the `request` object. Each handler automatically receives a `context` key added to the request by the [`wrap-context`](https://github.com/abogoyavlensky/reitit-extras/blob/32bde6d826603a3a0084d3266c5b936e7b802562/src/reitit_extras/core.clj#L182) middleware,
as well as a router. The `context` contains all system components of our application, allowing us to access the `db` component with its connection
pool to create a new movie.

In the same response, we return the `views/list-item` UI component with the newly created movie as an [out-of-band](https://htmx.org/examples/update-other-content/#oob)
element. This will be added to the end of the table. The table is identified by the `id` attribute `table-content` that we added in the previous step.

Now let's add a new route for this handler.

```clj title="src/myproject/routes.clj"
; ...

(def routes
  [["/" {:name ::home-page
            :get {:handler handlers/home-handler}
            :responses {200 {:body string?}}}]
   // [!code highlight]
   ["/movies"
    // [!code highlight]
    ["" {:name ::movie-list
         // [!code highlight]
         :post {:handler handlers/create-movie-handler
                // [!code highlight]
                :responses {200 {:body string?}}}}]]])
```

<Callout type="info">
 We're not adding a schema for request parameters in the route definition because we'll validate them in the handler itself. This approach allows us to return validation errors as part of the HTML response.
 This is why we retrieve parameters from the `params` key of the request, which comes from the [`wrap-nested-params`](https://github.com/abogoyavlensky/reitit-extras/blob/32bde6d826603a3a0084d3266c5b936e7b802562/src/reitit_extras/core.clj#L186-L187) middleware,
 rather than using the [`parameters-middleware`](https://github.com/abogoyavlensky/reitit-extras/blob/32bde6d826603a3a0084d3266c5b936e7b802562/src/reitit_extras/core.clj#L184), which would require a schema definition in the route.
</Callout>

And last thing. To show the home page properly let's update the handler for it passing `router` and `movies` list from the database:

```clj title="src/myproject/handlers.clj"
;...
(defn home-handler
  [{:keys [context]
    // [!code highlight]
    router :reitit.core/router}]
  // [!code highlight]
  (-> {:router router
       // [!code highlight]
       :movies (queries/get-movie-list (:db context))}
      (views/home-page)
      (reitit-extras/render-html)))
;...
```

### Frontend Implementation

Finally, we need to update our form to send requests to our newly created route:

```clj title="src/myproject/views.clj"
;...

(defn form-input
  // [!code highlight]
  [{:keys [field-name field-type field-value attrs]}]
  [:div
   {:class ["flex" "flex-col"]}
   [:input (merge {:class ["w-full" "border" "border-gray-300" "rounded-md" "px-3" "py-2"]
                   :type field-type
                   :name field-name
                   // [!code highlight]
                   :value (or field-value "")
                   :placeholder (str "Enter " field-name)}
                  attrs)]])

(defn form
  // [!code highlight]
  [{:keys [router]}]
  [:form
   (cond-> {:id "form-create-movie"
            :class ["border-t" "border-gray-200" "bg-gray-50" "p-6"]
            // [!code highlight]
            :hx-post (reitit-extras/get-route router ::routes/movie-list)
            // [!code highlight]
            :hx-target "#form-create-movie"
            // [!code highlight]
            :hx-swap "outerHTML"})
   // [!code highlight]
   (reitit-extras/csrf-token-html)
   ;...
   ])

(defn home-page
  // [!code highlight]
  [{:keys [movies router]}]
  (base
    [:div {:id "content"
           :class ["container" "mx-auto" "p-6" "max-w-4xl"]}
     [:div {:class ["mb-10" "flex" "justify-between" "items-center"]}
      [:h1 {:class ["text-2xl" "font-semibold" "text-gray-800"]} "Movies Lite"]]
     [:div {:class ["bg-white" "rounded-lg" "shadow-md" "overflow-hidden" "border"
                    "border-gray-200"]}
      ; ...
      // [!code highlight]
      (form {:router router})]]))
```

We need to pass several important parameters to our components:

1. The `router` to the page view function, allowing us to build URLs for creating movies by name
2. The `params` to form inputs so we can display them in case of validation errors
3. The `movies` list to render the table content

We've updated the form with several HTMX attributes:
- `:hx-post` with the new route URL
- `:hx-target` with the ID of the table content we added earlier
- `:hx-swap "outerHTML"` to replace the entire form with the response content

When a new movie is created, a new table row will be added to the table using the `:hx-swap-oob` attribute in our handler response.

To enable secure `POST` requests, we've added a hidden input with a CSRF token.

Now, after reloading the system in the REPL with `(reset)`, we should be able to create new movies using our form:

![Create movie 1](@/public/lite_create_1.png)

![Create movie 2](@/public/lite_create_2.png)

## Form Validation

Our form can create a movie, but what happens if we don't fill in the title field? It will throw an error because this field is required in the database.
Let's add parameter validation before inserting data into the database and display validation errors on the page.

Typically, we would define parameter validation as part of the router using Malli. However, to return custom HTML with validation messages,
we'll implement this validation directly in the handler.

```clojure title="src/myproject/handlers.clj"
(ns myproject.handlers
            // [!code highlight]
  (:require [malli.core :as m]
            // [!code highlight]
            [malli.error :as me]
            // [!code highlight]
            [malli.transform :as mt]
            [myproject.queries :as queries]
            [myproject.views :as views]
            [reitit-extras.core :as reitit-extras]
            [ring.util.response :as response]))

; ...
// [!code highlight]
(defn validate-params!
  // [!code highlight]
  "Validate router parameters and return human-readable errors."
  // [!code highlight]
  [schema data]
  // [!code highlight]
  (try
    // [!code highlight]
    (m/coerce schema data (mt/transformer mt/strip-extra-keys-transformer
                                          // [!code highlight]
                                          mt/string-transformer))
    // [!code highlight]
    (catch Exception e
      // [!code highlight]
      {:errors (-> e (ex-data) :data :explain me/humanize)})))


(defn create-movie-handler
  "Render a new table item with newly created movie."
  [{router :reitit.core/router
    :keys [context params]}]
  // [!code highlight]
  (let [validated-params (validate-params! [:map
                                            // [!code highlight]
                                            [:title [:string {:min 1}]]
                                            // [!code highlight]
                                            [:year pos-int?]
                                            // [!code highlight]
                                            [:director [:string {:min 1}]]]
                                           // [!code highlight]
                                           params)]
    // [!code highlight]
    (if (seq (:errors validated-params))
      // [!code highlight]
      (-> {:router router
           // [!code highlight]
           :errors (:errors validated-params)
           // [!code highlight]
           :params params}
          // [!code highlight]
          (views/form)
          // [!code highlight]
          (reitit-extras/render-html))
      (-> (list
            (views/form {:router router})
            [:template
             [:tbody
              {:hx-swap-oob "beforeend:#table-content"}
              (views/list-item {:router router
                                :movie (queries/create-movie (:db context) params)})]])
          (reitit-extras/render-html)
          (response/header "Content-Type" "text/html")))))
```

If validation errors are found, we return them as part of the response to the form, allowing users to correct their input.
If the request is valid, we create a new movie and return it as part of the response along with an empty form, just as we did before.


On the frontend part we add `errors` to the form input and show them below the input field.

```clojure title="src/myproject/views.clj"
; ...

(defn form-input
  // [!code highlight]
  [{:keys [field-name field-type field-value errors attrs]}]
  [:div
   ; ...
   // [!code highlight]
   (for [err errors]
     // [!code highlight]
     [:p {:class ["text-red-500" "text-xs" "mt-1" "h-4"]} (str/capitalize err)])])

(defn form
  // [!code highlight]
  [{:keys [router errors params]}]
  [:form
   (cond-> {:id "form-create-movie"
            :class ["border-t" "border-gray-200" "bg-gray-50" "p-6"]
            :hx-post (reitit-extras/get-route router ::routes/movie-list)
            :hx-target "#form-create-movie"
            :hx-swap "outerHTML"})
   (reitit-extras/csrf-token-html)
   [:div {:class ["grid" "grid-cols-1" "md:grid-cols-4" "gap-4"]}
    (form-input {:field-name "title"
                 :field-type "text"
                 :field-value (:title params)
                 // [!code highlight]
                 :errors (:title errors)})
    (form-input {:field-name "year"
                 :field-type "number"
                 :field-value (:year params)
                 // [!code highlight]
                 :errors (:year errors)
                 :attrs {:min 1888}})
    (form-input {:field-name "director"
                 :field-type "text"
                 :field-value (:director params)
                 // [!code highlight]
                 :errors (:director errors)})
    [:div {:class ["flex" "flex-col"]}
     [:button {:class ["bg-blue-600" "text-white" "rounded-md" "px-4" "py-2"
                       "hover:bg-blue-700" "cursor-pointer"]}
      "Create"]]]])

```

![Create form validation errors](@/public/lite_create_2.png)

## Delete a movie

Now we can add a delete button to each row of the table. We will use `:hx-delete` attribute to send a request to the server.
Then we add `"closest tr"` as `:hx-target` to remove the row from the table. Also we need to add csrf token to the request header.

```clojure title="src/myproject/views.clj"
; ...

(defn list-item
  [{:keys [router movie]}]
  [:tr
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:title movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:year movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:director movie)]
   [:td {:class ["px-6" "py-4"]}
   // [!code highlight]
    [:button
    // [!code highlight]
     {:class ["text-red-400" "hover:bg-gray-50" "bg-white" "border"
              // [!code highlight]
              "border-gray-300" "rounded-md" "px-3" "py-1" "cursor-pointer"]
      // [!code highlight]
      :hx-delete (reitit-extras/get-route router ::routes/movie-details {:path {:id (:id movie)}})
      // [!code highlight]
      :hx-headers (reitit-extras/csrf-token-json)
      // [!code highlight]
      // [!code highlight]
      :hx-target "closest tr"
      // [!code highlight]
      :hx-swap "outerHTML"}
     // [!code highlight]
     "Delete"]]])

(defn home-page
  [{:keys [router movies]}]
  (base
    [:div {:id "content"
           :class ["container" "mx-auto" "p-6" "max-w-4xl"]}
     ; ...
     [:div {:class ["bg-white" "rounded-lg" "shadow-md" "overflow-hidden" "border" "border-gray-200"]}
      [:div {:class ["overflow-x-auto"]}
       [:table {:class ["min-w-full" "divide-y" "divide-gray-200"]}
        ; ...
        [:tbody {:id "table-content"
                 :class ["bg-white" "divide-y" "divide-gray-200"]}
         (for [movie movies]
          // [!code highlight]
           (list-item {:router router
                       :movie movie}))]]]
      (form {:router router})]]))
```

Now, clicking on the delete button will remove the row from the table.

## Testing

We have a simple application that we can test. Let's start with fixing existing test:

```clojure title="test/myproject/home_test.clj"
; ...

(deftest test-home-page-is-loaded-correctly
  (let [server (::server/server ig-extras/*test-system*)
        url (reitit-extras/get-server-url server :host)
        body (-> (hato/get url)
                 :body
                 (hickory/parse)
                 (hickory/as-hickory))]
    // [!code highlight]
    (is (= "Movies Lite"
           (->> body
                (select/select (select/tag :h1))
                (first)
                :content
                (first))))))
```

Now if you run `bb test` it should pass.

We can update this test to check if we can show a movie on a page:

```clojure title="test/myproject/home_test.clj"
(ns myproject.home-test
  (:require ; ...
            // [!code highlight]
            [myproject.queries :as queries]
            [myproject.server :as-alias server]
            ;...
            ))

(deftest test-home-page-is-loaded-correctly
  (let [server (::server/server ig-extras/*test-system*)
        // [!code highlight]
        db (::db/db ig-extras/*test-system*)
        url (reitit-extras/get-server-url server :host)
        // [!code highlight]
        _ (queries/create-movie db {:title "The Matrix"
                                    // [!code highlight]
                                    :year 1999
                                    // [!code highlight]
                                    :director "Lana Wachowski, Lilly Wachowski"})
        body (-> (http/get url)
                 :body
                 (hickory/parse)
                 (hickory/as-hickory))]
    (is (= "Movies Lite"
           (->> body
                (select/select (select/tag :h1))
                (first)
                :content
                (first))))
    // [!code highlight]
    (is (= ["The Matrix" "1999" "Lana Wachowski, Lilly Wachowski"]
           // [!code highlight]
           (->> body
                // [!code highlight]
                (select/select (select/tag :td))
                // [!code highlight]
                (map (comp first :content))
                // [!code highlight]
                (butlast))))))
```

Now we can add test for creating a movie:

```clojure title="test/myproject/home_test.clj"
(deftest test-create-movie-ok
  (let [server (::server/server ig-extras/*test-system*)
        db (::db/db ig-extras/*test-system*)
        base-url (reitit-extras/get-server-url server :host)
        url (str base-url "/movies")
        {:keys [csrf-token cookies]} (test-utils/get-csrf-token-and-cookies base-url)]
    ; Create a new movie
    (http/post url {:cookies cookies
                    :form-params {test-utils/CSRF-TOKEN-KEY csrf-token
                                  :title "The Matrix"
                                  :year 1999
                                  :director "Lana Wachowski, Lilly Wachowski"}})

    (is (= [{:director "Lana Wachowski, Lilly Wachowski"
             :title "The Matrix"
             :year 1999}]
           (db/exec! db {:select [:title :year :director]
                         :from [:movie]})))))
```

Notice how we get csrf-token from the page and add it to the request header using cookies.

And one for deleting a movie:

```clojure title="test/myproject/home_test.clj"
(deftest test-delete-movie-ok
  (let [server (::server/server ig-extras/*test-system*)
        db (::db/db ig-extras/*test-system*)
        base-url (reitit-extras/get-server-url server :host)
        movie (queries/create-movie db {:title "The Matrix"
                                        :year 1999
                                        :director "Lana Wachowski, Lilly Wachowski"})
        url (str base-url "/movies/" (:id movie))
        {:keys [csrf-token cookies]} (test-utils/get-csrf-token-and-cookies base-url)]
    ; Delete the movie
    (http/delete url {:cookies cookies
                      :headers {test-utils/CSRF-TOKEN-HEADER csrf-token}})

    (is (= [] (db/exec! db {:select [:*]
                            :from [:movie]})))))
```

## Summary

In this quick tutorial we created a simple application with Clojure Stack Lite.
We've seen how to create a new project, start the server and create a simple application with a form and a table.
We performed `POST` request, `GET` reuest and `DELETE` request using HTMX, with form validation and error handling.

For real-world application you might want to add more features like: user authentication/authorization,
list pagination, etc. But this is a good starting point to build your own application.

## Next steps

From this point you can continue with deploying your application to production or learn more about
project structure and how to manage the project in the "Guide" section.

import { Rocket, BookOpenText } from 'lucide-react';

<Cards>
    <Card title="Deployment" href="/docs/lite/kamal" icon={<Rocket />}>
      Deploy your application to production with Kamal
    </Card>
    <Card title="Local Development" href="/docs/lite/local-development" icon={<BookOpenText />}>
      Learn how to setup local development environment
    </Card>
</Cards>

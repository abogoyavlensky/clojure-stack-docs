---
title: Tutorial
description: Let's build your first application with Clojure Stack Lite
icon: Play
---

We just created a new project and ready to get started. Let's build a simple application.

## After generating project

First thing is recommended to do is checking the code formatting, linting, tests and outdated deps.
You will need [Docker](https://docs.docker.com/engine/install/) installed on your system as tests are running Testcontainers using Docker.

```shell
bb check
```

Now we can initiate git-repository and commit initial setup:

```shell
git init
git add .
git commit -am 'Initial commit'
```

## Start server

Navigate to project root and run REPL:

```shell
cd myproject
bb clj-repl
```

Then once we are in the REPL we can run the application system with server, database and TailwindCSS CLI components:

```shell
user=> (reset)
```

_TODO: add link to setup editor doc_

## Change starter page

Let's change something on the starter page and see the result. Open `src/myproject/views.clj` file
and replace ui component `:h1` to `[:h1 {:class ["text-5xl"]} "Hello world!"]`.
After reloading the page you will see that title has been changed on the web page.

![Clojure Stack Lite starter page](@/public/starter_hello.png)

## Application system components

The entry point of an application is `src/myproject/core.clj`. There is one function `main` that runs the system with production profile.
We use Integrant as a framework for running all components of the system. Core components are `db` and `server` and they are defined in
`src/myproject/db.clj` and `src/myproject/server.clj` appropriately. The defualt configuration of server component is described in the
separate library `reitit-extras`, this is just shortcut for convenience. It has few options to extend server configuration.
If you want to change or replace amything in the server configuration, just copy server definition from `reitit-extras` to your project.

In development mode entry point is `dev/user.clj`. There we start the same system with dev profile and an extension of config `resources/config.dev` that contains
just one additional component to start `tailwindcss` CLI tool in watch mode to auto-reload css styles on file change. So it's started as part of the application system and we don't need to
run it separately.

## The application

All set up and we are ready to create our application. As I mentioned earlier we are going to build movie list application called "Movies Lite".
There will be an ability to add a new movie, show the list of movies and delete a row from the list.

## Database structure

For simplicity we will create one table called `movie` with fields `id`, `title`, `year`, `director`.
To create this schema please add following database migration by creating a new file `resources/migrations/0002.up.sql` with content:

```sql title="resources/migrations/0002.up.sql"
CREATE TABLE movie (
    id INTEGER UNIQUE PRIMARY KEY AUTOINCREMENT NOT NULL,
    title TEXT NOT NULL,
    year INTEGER NOT NULL,
    director TEXT NOT NULL
);
```

Migrations are applied as part of the system start. So, to apply our new migrations we can run `(reset)` in the REPL.
After it we can connect to our database using any SQLite client (for example [TablePlus](https://tableplus.com/)) and check that we actually created the table `movie`:

![Movies DB table](@/public/lite_movies_db_table.png)

## Application UI layout

To visualise all parts of the application let's create a UI layout for our main page.
Let's look at `src/myproject/views.clj`. This namespace contains functions that converts data to Hiccup templates.
That we will convert to HTML at rendering response step. There is a `base` function that contains default setup for all pages
with page title, static files and a placeholder for any content we want to show on the page.

Mockup of the page we are going to build looks like:

![UI mockup](@/public/lite_mockup.png)

There is a page title and a table with list of movies. Each row has button "Delete" at the last column.
At the bottom of the table there is a form to create a new movie.

Our `home-page` function and additional functions will look like:

```clojure title="src/myproject/views.clj"
; ...
(defn list-item
  [{:keys [movie]}]
  [:tr
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:title movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:year movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:director movie)]
   [:td {:class ["px-6" "py-4"]}
    [:button
     {:class ["text-red-400" "hover:bg-gray-50" "bg-white" "border"
              "border-gray-300" "rounded-md" "px-3" "py-1" "cursor-pointer"]}
     "Delete"]]])

(defn form-input
  [{:keys [field-name field-type attrs]}]
  [:div
   {:class ["flex" "flex-col"]}
   [:input (merge {:class ["w-full" "border" "border-gray-300" "rounded-md" "px-3" "py-2"]
                   :type field-type
                   :name field-name
                   :placeholder (str "Enter " field-name)}
                  attrs)]])

(defn form
  []
  [:form
   (cond-> {:id "form-create-movie"
            :class ["border-t" "border-gray-200" "bg-gray-50" "p-6"]})
   [:div {:class ["grid" "grid-cols-1" "md:grid-cols-4" "gap-4"]}
    (form-input {:field-name "title"
                 :field-type "text"})
    (form-input {:field-name "year"
                 :field-type "number"
                 :attrs {:min 1888}})
    (form-input {:field-name "director"
                 :field-type "text"})
    [:div {:class ["flex" "flex-col"]}
     [:button {:class ["bg-blue-600" "text-white" "rounded-md" "px-4" "py-2"
                       "hover:bg-blue-700" "cursor-pointer"]}
      "Create"]]]])

(defn home-page
  [{:keys [movies]}]
  (base
    [:div {:id "content"
           :class ["container" "mx-auto" "p-6" "max-w-4xl"]}
     [:div {:class ["mb-10" "flex" "justify-between" "items-center"]}
      [:h1 {:class ["text-2xl" "font-semibold" "text-gray-800"]} "Movies Lite"]]
     [:div {:class ["bg-white" "rounded-lg" "shadow-md" "overflow-hidden" "border"
                    "border-gray-200"]}
      [:div {:class ["overflow-x-auto"]}
       [:table {:class ["min-w-full" "divide-y" "divide-gray-200"]}
        [:thead {:class ["bg-white"]}
         [:tr
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Title"]
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Year"]
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Director"]
          [:th {:class ["px-6" "py-3" "text-left" "text-gray-500" "font-medium"]
                :scope "col"} "Actions"]]]
        [:tbody {:id "table-content"
                 :class ["bg-white" "divide-y" "divide-gray-200"]}
         (for [movie movies]
           (list-item {:movie movie}))]]]
      (form)]]))
```

We also moved list item, form and form inputs to separate components for convenience and as we will need to rendered it separately for created movie
in the next section.

We need to update our `home-handler` to pass fake data for `movies` to show them on the page:

```clojure title="src/myproject/handlers.clj"
; ...
(defn home-handler
  [_]
  (-> {:movies [{:title "Movie 1"
                 :year 2023
                 :director "Director 1"}
                {:title "Movie 2"
                 :year 2022
                 :director "Director 2"}]}
      (views/home-page)
      (reitit-extras/render-html)))
```

After refreshing page in the browser it will look like:

![Page layout](@/public/lite_page_layout.png)

## Create movie

We have a basic ui part for the table and form. Now we can add a new route and handler for creating a movie.

### Backend

First, we add sql queries for creating and fetching a movies. Let's create a new file `queries.clj`:

```clj title="src/myproject/queries.clj"
(ns myproject.queries
  (:require [myproject.db :as db]))

(defn get-movie-list
  [db]
  (db/exec! db {:select [:*]
                :from [:movie]
                :order-by [:id]}))

(defn create-movie
  [db {:keys [title year director]}]
  (db/exec-one! db {:insert-into :movie
                    :values [{:title title
                              :year year
                              :director director}]
                    :returning [:*]}))
```

Now we can add a new handler for creating a movie:

```clojure title="src/myproject/handlers.clj"
(ns myproject.handlers
  // [!code highlight]
  (:require [myproject.queries :as queries]
            ; ...
            )

; ...

(defn create-movie-handler
  "Render a new table item with newly created movie."
  [{router :reitit.core/router
    :keys [context params]}]
  (-> (list
        (views/form {:router router})
        [:template
         [:tbody
          {:hx-swap-oob "beforeend:#table-content"}
          (views/list-item {:router router
                            :movie (queries/create-movie (:db context) params)})]])
      (reitit-extras/render-html)
      (response/header "Content-Type" "text/html")))
```

Single parameter of a handler is `request`. Each handler will have a key `context` add to request by default (using middleware [`wrap-context`](https://github.com/abogoyavlensky/reitit-extras/blob/32bde6d826603a3a0084d3266c5b936e7b802562/src/reitit_extras/core.clj#L182))
and a router. `context` has all system components of our application, so we can use a `db` component with connection
pool to create a new movie.

Also in the same response we return `views/list-item` ui component with newly created movie as [out-of-bound](https://htmx.org/examples/update-other-content/#oob)
element that will be added at the end of the table. The table will be found by `id` `table-content` that we added to the table in the previous step.

Now let's add a new route for this handler.

```clj title="src/myproject/routes.clj"
; ...

(def routes
  [["/" {:name ::home-page
            :get {:handler handlers/home-handler}
            :responses {200 {:body string?}}}]
   // [!code highlight]
   ["/movies"
    // [!code highlight]
    ["" {:name ::movie-list
         // [!code highlight]
         :post {:handler handlers/create-movie-handler
                // [!code highlight]
                :responses {200 {:body string?}}}}]]])
```

<Callout type="info">
 We do not add schema for request parameters as we are going to validate them in the handler itself to be able to return validation errors as part of the HTML response.
 That is why we got parameters in the handler from `params` key of the request that comes from [`wrap-nested-params`](https://github.com/abogoyavlensky/reitit-extras/blob/32bde6d826603a3a0084d3266c5b936e7b802562/src/reitit_extras/core.clj#L186-L187) middleware
 instead of the [`parameters-middleware`](https://github.com/abogoyavlensky/reitit-extras/blob/32bde6d826603a3a0084d3266c5b936e7b802562/src/reitit_extras/core.clj#L184), as the last one requires schema definition in the route.
</Callout>

And last thing. To show the home page properly let's update the handler for it passing `router` and `movies` list from the database:

```clj title="src/myproject/handlers.clj"
;...
(defn home-handler
  [{:keys [context]
    // [!code highlight]
    router :reitit.core/router}]
  // [!code highlight]
  (-> {:router router
       // [!code highlight]
       :movies (queries/get-movie-list (:db context))}
      (views/home-page)
      (reitit-extras/render-html)))
;...
```

### Frontend

And finally, we need to update our form such that it will send request to our new route:

```clj title="src/myproject/views.clj"
;...

(defn form-input
  // [!code highlight]
  [{:keys [field-name field-type field-value attrs]}]
  [:div
   {:class ["flex" "flex-col"]}
   [:input (merge {:class ["w-full" "border" "border-gray-300" "rounded-md" "px-3" "py-2"]
                   :type field-type
                   :name field-name
                   // [!code highlight]
                   :value (or field-value "")
                   :placeholder (str "Enter " field-name)}
                  attrs)]])

(defn form
  // [!code highlight]
  [{:keys [router]}]
  [:form
   (cond-> {:id "form-create-movie"
            :class ["border-t" "border-gray-200" "bg-gray-50" "p-6"]
            // [!code highlight]
            :hx-post (reitit-extras/get-route router ::routes/movie-list)
            // [!code highlight]
            :hx-target "#form-create-movie"
            // [!code highlight]
            :hx-swap "outerHTML"})
   // [!code highlight]
   (reitit-extras/csrf-token-html)
   ;...
   ])

(defn home-page
  // [!code highlight]
  [{:keys [movies router]}]
  (base
    [:div {:id "content"
           :class ["container" "mx-auto" "p-6" "max-w-4xl"]}
     [:div {:class ["mb-10" "flex" "justify-between" "items-center"]}
      [:h1 {:class ["text-2xl" "font-semibold" "text-gray-800"]} "Movies Lite"]]
     [:div {:class ["bg-white" "rounded-lg" "shadow-md" "overflow-hidden" "border"
                    "border-gray-200"]}
      ; ...
      // [!code highlight]
      (form {:router router})]]))
```

We need to pass `router` to the page view function to be able to build an url for creating a movie by its name.
We need to pass `params` to the form inputs to be able to show them in case of validation error.
Also we need to pass movies list to be able to render the table.

Then we update form with `:hx-port` attribute with new route, `:hx-target` with the id of a table content
that we added at previous step. We are going to return HTML for the form as main content of the response and replace the whole form with:
`:hx-swap "outerHTML"`. A new table row with a movie will be added to the table using `:hx-swap-oob` attribute.

To be able to send `POST` request we added a hidden input with csrf-token.

Now once we reload the system in REPL `(reset)` we should be able to create a new movie using our form.

![Create movie 1](@/public/lite_create_1.png)

![Create movie 2](@/public/lite_create_2.png)

## Form errors

Our for can create a movie but what if we don't fill title? It will throw an error, because this field is required in the database.
Let's add parameters validation before inserting data to the database. We also need showing validation errors on the page.

Usually, we would describe params validation as part of router using Malli, but to be able to return different HTML with validation messages
we will move this validation to the handler itself.

```clojure title="src/myproject/handlers.clj"
(ns myproject.handlers
            // [!code highlight]
  (:require [malli.core :as m]
            // [!code highlight]
            [malli.error :as me]
            // [!code highlight]
            [malli.transform :as mt]
            [myproject.queries :as queries]
            [myproject.views :as views]
            [reitit-extras.core :as reitit-extras]
            [ring.util.response :as response]))

; ...
// [!code highlight]
(defn validate-params!
  // [!code highlight]
  "Validate router parameters and return human-readable errors."
  // [!code highlight]
  [schema data]
  // [!code highlight]
  (try
    // [!code highlight]
    (m/coerce schema data (mt/transformer mt/strip-extra-keys-transformer
                                          // [!code highlight]
                                          mt/string-transformer))
    // [!code highlight]
    (catch Exception e
      // [!code highlight]
      {:errors (-> e (ex-data) :data :explain me/humanize)})))


(defn create-movie-handler
  "Render a new table item with newly created movie."
  [{router :reitit.core/router
    :keys [context params]}]
  // [!code highlight]
  (let [validated-params (validate-params! [:map
                                            // [!code highlight]
                                            [:title [:string {:min 1}]]
                                            // [!code highlight]
                                            [:year pos-int?]
                                            // [!code highlight]
                                            [:director [:string {:min 1}]]]
                                           // [!code highlight]
                                           params)]
    // [!code highlight]
    (if (seq (:errors validated-params))
      // [!code highlight]
      (-> {:router router
           // [!code highlight]
           :errors (:errors validated-params)
           // [!code highlight]
           :params params}
          // [!code highlight]
          (views/form)
          // [!code highlight]
          (reitit-extras/render-html))
      (-> (list
            (views/form {:router router})
            [:template
             [:tbody
              {:hx-swap-oob "beforeend:#table-content"}
              (views/list-item {:router router
                                :movie (queries/create-movie (:db context) params)})]])
          (reitit-extras/render-html)
          (response/header "Content-Type" "text/html")))))
```

If we found validation errors we return them as part of the response to the form.
If the request is valid we create a new movie and return it as part of the response along with the empty form, exactly as before.


On the frontend part we add `errors` to the form input and show them below the input field.

```clojure title="src/myproject/views.clj"
; ...

(defn form-input
  // [!code highlight]
  [{:keys [field-name field-type field-value errors attrs]}]
  [:div
   ; ...
   // [!code highlight]
   (for [err errors]
     // [!code highlight]
     [:p {:class ["text-red-500" "text-xs" "mt-1" "h-4"]} (str/capitalize err)])])

(defn form
  // [!code highlight]
  [{:keys [router errors params]}]
  [:form
   (cond-> {:id "form-create-movie"
            :class ["border-t" "border-gray-200" "bg-gray-50" "p-6"]
            :hx-post (reitit-extras/get-route router ::routes/movie-list)
            :hx-target "#form-create-movie"
            :hx-swap "outerHTML"})
   (reitit-extras/csrf-token-html)
   [:div {:class ["grid" "grid-cols-1" "md:grid-cols-4" "gap-4"]}
    (form-input {:field-name "title"
                 :field-type "text"
                 :field-value (:title params)
                 // [!code highlight]
                 :errors (:title errors)})
    (form-input {:field-name "year"
                 :field-type "number"
                 :field-value (:year params)
                 // [!code highlight]
                 :errors (:year errors)
                 :attrs {:min 1888}})
    (form-input {:field-name "director"
                 :field-type "text"
                 :field-value (:director params)
                 // [!code highlight]
                 :errors (:director errors)})
    [:div {:class ["flex" "flex-col"]}
     [:button {:class ["bg-blue-600" "text-white" "rounded-md" "px-4" "py-2"
                       "hover:bg-blue-700" "cursor-pointer"]}
      "Create"]]]])

```

![Create form validation errors](@/public/lite_create_2.png)

## Delete a movie

Now we can add a delete button to each row of the table. We will use `:hx-delete` attribute to send a request to the server.
Then we add `"closest tr"` as `:hx-target` to remove the row from the table. Also we need to add csrf token to the request header.

```clojure title="src/myproject/views.clj"
; ...

(defn list-item
  [{:keys [router movie]}]
  [:tr
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:title movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:year movie)]
   [:td {:class ["px-6" "py-4" "text-gray-800"]} (:director movie)]
   [:td {:class ["px-6" "py-4"]}
   // [!code highlight]
    [:button
    // [!code highlight]
     {:class ["text-red-400" "hover:bg-gray-50" "bg-white" "border"
              // [!code highlight]
              "border-gray-300" "rounded-md" "px-3" "py-1" "cursor-pointer"]
      // [!code highlight]
      :hx-delete (reitit-extras/get-route router ::routes/movie-details {:path {:id (:id movie)}})
      // [!code highlight]
      :hx-headers (reitit-extras/csrf-token-json)
      // [!code highlight]
      // [!code highlight]
      :hx-target "closest tr"
      // [!code highlight]
      :hx-swap "outerHTML"}
     // [!code highlight]
     "Delete"]]])

(defn home-page
  [{:keys [router movies]}]
  (base
    [:div {:id "content"
           :class ["container" "mx-auto" "p-6" "max-w-4xl"]}
     ; ...
     [:div {:class ["bg-white" "rounded-lg" "shadow-md" "overflow-hidden" "border" "border-gray-200"]}
      [:div {:class ["overflow-x-auto"]}
       [:table {:class ["min-w-full" "divide-y" "divide-gray-200"]}
        ; ...
        [:tbody {:id "table-content"
                 :class ["bg-white" "divide-y" "divide-gray-200"]}
         (for [movie movies]
          // [!code highlight]
           (list-item {:router router
                       :movie movie}))]]]
      (form {:router router})]]))
```

Now, clicking on the delete button will remove the row from the table.

## Summary

In this quick tutorial we created a simple application with Clojure Stack Lite.
We've seen how to create a new project, start the server and create a simple application with a form and a table.
We performed `POST` request, `GET` reuest and `DELETE` request using HTMX, with form validation and error handling.

For real-world application you might want to add more features like: user authentication/authorization,
list pagination, etc. But this is a good starting point to build your own application.

## Next steps

From this point you can continue with deploying your application to production or learn more about
project structure and how to manage the project in the "Guide" section.

import { Rocket, BookOpenText } from 'lucide-react';

<Cards>
    <Card title="Deployment" href="/docs/lite/kamal" icon={<Rocket />}>
      Deploy your application to production with Kamal
    </Card>
    <Card title="Local Development" href="/docs/lite/local-development" icon={<BookOpenText />}>
      Learn how to setup local development environment
    </Card>
</Cards>
